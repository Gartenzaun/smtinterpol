%----------------------------------------
\subsubsection*{Related Work.}
%----------------------------------------

\begin{techreport}
Craig~\cite{Craig2011} shows in his seminal work on interpolation that for
every inconsistent pair of first order formulae an interpolant can be
derived. In the proof of the corresponding theorem he shows how to construct
interpolants without proofs by introducing quantifiers in the interpolant.
\end{techreport}
For Boolean circuits, Pudl\'ak~\cite{DBLP:journals/jsyml/Pudlak97} shows how
to construct quantifier-free interpolants from resolution proofs of
unsatisfiability.
\begin{techreport}

\end{techreport}
%
A different proof-based interpolation system is given by
McMillan~\cite{DBLP:conf/tacas/McMillan04} in his seminal paper on
interpolation for SMT. The presented method combines the theory of equality
and uninterpreted functions with the theory of linear rational
arithmetic. Interpolants are computed from partial interpolants by annotating
every proof step. The partial interpolants have a specific form that carries
information needed to combine the theories. The proof system is incomplete for
linear integer arithmetic as it cannot deal with arbitrary cuts and mixed
literals introduced by these cuts.

Brillout et al.~\cite{DBLP:conf/vmcai/BrilloutKRW11} present an interpolating
sequent calculus that can compute interpolants for the combination of
uninterpreted functions and linear integer arithmetic. The interpolants
computed using their method might contain quantifiers since they do not use
divisibility predicates. Furthermore their method limits the generation of
Gomory cuts in the integer solver to prevent some mixed cuts. The method
presented in this paper combines the two theories without quantifiers and,
furthermore, does not restrict any component of the solver.

Yorsh and Musuvathi~\cite{Yorsh2005} show how to combine interpolants
generated by an SMT solver based on Nelson-Oppen combination. They define the
concept of \emph{equality-interpolating theories}. These are theories that
can provide a shared term $t$ for 
a mixed literal $a=b$ that is derivable from an interpolation problem.
A troublesome mixed interface equality $a=b$ is rewritten into the
conjunction $a=t\land t=b$. They show that both, the theory of uninterpreted
functions and the theory of linear rational arithmetic are
equality-interpolating. We do not explicitly split the proof.
Additionally, our method can handle the
theory of linear integer arithmetic without any restriction on the solver. 
\begin{techreport}
The method of Yorsh and Musuvathi, however, cannot deal with cuts used by most
modern SMT solvers to decide linear integer arithmetic.
\end{techreport}

Cimatti et al.~\cite{Cimatti2010} present a method to compute interpolants for
linear rational arithmetic and difference logic. The method presented in this paper builds upon
their interpolation technique for linear rational arithmetic. For theories combined via delayed
theory combination, they show how to compute interpolants by
transforming a proof into a so-called \emph{ie-local} proof.  In these proofs,
mixed equalities are close to the leaves of the proof tree and
splitting them is cheap since the proof trees that have to be
duplicated are small. 
\begin{techreport}
A variant of this restricted search strategy is used by
MathSAT~\cite{Griggio2012} and CSIsat~\cite{DBLP:conf/cav/BeyerZM08}.
\end{techreport}

Goel et al.~\cite{Goel2009} present a generalisation of
equality-interpolating theories. They define the class of
\emph{almost-colourable proofs} and an algorithm to generate interpolants from
such proofs. Furthermore they describe a restricted DPLL system to generate
almost-colourable proofs. This system does not restrict the search if convex
theories are used. Their procedure is incomplete for non-convex theories like
linear arithmetic over integers since it prohibits the generation of mixed 
branches and cuts.

Recently, techniques to transform proofs gained a lot of
attention. Bruttomesso et al.~\cite{Bruttomesso2010} present a framework to
lift resolution steps on mixed literals into the leaves of the resolution
tree. Once a subproof only resolves on mixed literals, they replace this
subproof with the conclusion removing the mixed inferences. 
The newly generated lemmas however are mixed between different theories and require
special interpolation procedures. Even though these procedures only have to
deal with conjunctions of literals in the combined theories it is not obvious
how to compute interpolants in this setting. 
\begin{techreport}
Similar to our algorithm, they do
not restrict or interact with the SMT solver but take the proof as produced by
the solver. 
\end{techreport}
In contrast to our approach, they manipulate the proof in a way
that is worst-case exponential and rely on an interpolant generator for the
conjunctive fragment of the combined theories.

McMillan~\cite{McMillan12iZ3} presents a technique
to compute interpolants from Z3 proofs. 
Whenever a sub-proof contains mixed
literals, he 
extracts lemmas from the proof tree and delegates them to a second
(possibly slower) interpolating solver.

\begin{techreport}
For the theory of linear integer arithmetic \laz\ a lot of
different techniques were proposed.  Lynch et
al.~\cite{DBLP:conf/atva/LynchT08} present a method that produces interpolants
as long as no mixed cuts were introduced.  In the presence of such cuts, their
interpolants might contain symbols that violate the symbol condition of Craig
interpolants.

For linear Diophantine equations and linear modular equations, Jain et
al.~\cite{DBLP:journals/fmsd/JainCG09} present a method to compute linear
modular equations as interpolants. Their method however is limited to
equations and, thus, not suitable for the whole theory \laz.

Griggio~\cite{Griggio2011} shows how to compute interpolants for \laz\ based
on the \laz-solver from MathSAT~\cite{Griggio2012}. This solver uses
branch-and-bound and the cuts from proofs~\cite{Dillig2011} technique. Similar
to the technique presented by Kroening et
al.~\cite{DBLP:conf/lpar/KroeningLR10} the algorithm prevents generating mixed
cuts and, hence, restricts the inferences done by the solver.
\end{techreport}
