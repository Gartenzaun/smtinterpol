\subsection{Purification of Mixed Literals}\label{sec:purification}

The proofs generated by state-of-the-art SMT solvers may contain mixed literals. We tackle them by extending the projection functions to
these literals.  The problem here is that there is no projection
function that satisfies the conditions stated in the previous section.
Therefore, we relax the conditions by allowing fresh auxiliary
variables to occur in the projections.

We consider two different kinds of mixed literals: First, 
(dis-\nobreak)equalities of the form $a=b$ or $a\neq b$ for an $A$-local
variable $a$ and a $B$-local variable $b$ are introduced, e.\,g., by theory
combination or Ackermannization. Second, inequalities of the form $a + b \leq
c$ are introduced, e.\,g., by extended branches~\cite{Dillig2011} or bound
propagation. Here, $a$ is a linear combination of $A$-local variables,
$b$ is a linear combination of $B$-local and shared variables, and $c$ is a
constant.
\begin{techreport}
Adding the shared variable to the $B$-part is an arbitrary choice.  One gets
interpolants of different strengths by assigning some shared variables to the
$A$-part. It is only important to keep the projection of each literal
consistent throughout the proof.
\end{techreport}

\ifnewinterpolation
We split mixed literals using auxiliary variables, which we denote by
$x$ or $p_x$ in the following.  The variable $p_x$ has the type Boolean,
while $x$ has the same type as the variables in the literal.  One or
two fresh variables are introduced for each mixed literal.  We count
these variables as shared between $A$ and $B$.  The purpose of the
auxiliary variable $x$ is to capture the shared value that needs to be
propagated between $A$ and $B$.  When splitting a literal $\ell$ into
$A$- and $B$-part, we require that $\ell \Leftrightarrow \exists
x,p_x. (\ell\proj A) \land (\ell\proj B)$.  We need the additional
Boolean variable $p_x$ to split the literal $a\neq b$ into two (nearly)
symmetric parts.  This is achieved by the definitions below.
%
\begin{align*}
(a=b)\proj A & := (a=x) &
(a=b)\proj B & := (x=b) \\
(a\neq b)\proj A & := (p_x \xor a=x) &
(a\neq b)\proj B & := (\lnot p_x \xor x=b) \\
(a + b \leq c)\proj A & := (a + x\leq 0) &
(a + b \leq c)\proj B & := (-x + b\leq c)
\end{align*}
\else
We split mixed literals using auxiliary variables, which we denote by
$x$, $x_a$, or $x_b$ in the following.  One or two fresh variables are
introduced for each mixed literal.  We count these variables as shared
between $A$ and $B$.  The purpose of the auxiliary variables is to
capture the shared value that needs to be propagated between $A$ and $B$.
When splitting a literal $\ell$ into $A$- and $B$-part, we require that
$\ell \Leftrightarrow \exists x,x_a,x_b. (\ell\proj A) \land (\ell\proj B)$.
We need two variables $x_a$ and $x_b$ to split the literal $a\neq b$ into two
symmetric parts.  For symmetry we split the literal $a=b$ in the same fashion
instead of introducing only a single auxiliary variable.
This is achieved by the definitions below.
%
\begin{align*}
(a=b)\proj A & := (a=x_a \land x_a = x_b) &
(a=b)\proj B & := (x_a = x_b  \land x_b=b) \\
(a\neq b)\proj A & := (a=x_a \land x_a \neq x_b) &
(a\neq b)\proj B & := (x_a \neq x_b  \land x_b=b) \\
(a + b \leq c)\proj A & := (a + x\leq 0) &
(a + b \leq c)\proj B & := (-x + b\leq c)
\end{align*}
\fi
%
%
Since the mixed variables are considered to be shared, we allow them
to occur in the partial interpolant of a clause $C$.  However, a
variable may only occur if $C$ contains the corresponding literal.
This is achieved by a special interpolation rule for resolution steps
where the pivot literal is mixed.
The rules for the different mixed
literals are the core of our proposed algorithm and will be introduced
in the following sections.  

\ifnewinterpolation\else
Instead of with a single partial interpolant, we label each clause with a
pattern from which we can derive two partial interpolants, a strong and a weak
one.  The strong interpolant of a clause $C$ implies the weak interpolant under
the assumption that $\lnot C\proj A$ or $\lnot C\proj B$ holds.
Having two
interpolants enables us to complete the inductive proof.  
We show that the strong interpolant follows from the $A$-part of the
resolvent if the strong interpolants of the premises follow from their
respective $A$-part.  On the other hand, the weak interpolant is in
contradiction to the $B$-part in the resolvent if this is the case for
the premises.  Since the weak interpolant follows from the strong
interpolant this shows that both are partial interpolants.
The models for the strong and the weak interpolants only differ in the
values of the auxiliary variable.  The interpolants are needed because 
the ``right'' value
for the auxiliary variable is not known when interpolating the leaves 
of the proof tree.
The strong and the weak interpolant are identical if the clause does not
contain mixed literals.  Therefore, we derive only one interpolant for the
bottom clause.
\fi


\begin{techreport}
  \ifnewinterpolation
  \begin{lemma}[Partial Interpolation]\label{lem:weakstrongip}
    Given a mixed literal $\ell$ with auxiliary variable(s) $\vec x$
    and clauses $C_1\lor\ell$ and $C_2\lor\lnot\ell$ with corresponding 
    partial interpolants $I_1$ and $I_2$.  Let $C_3=C_1\lor C_2$ 
    be the result of a resolution step
    on $C_1\lor\ell$ and $C_2\lor\lnot\ell$ with pivot $\ell$.
    If a partial interpolant $I_3$ satisfies the symbol
    condition, and
    \begin{align*}
      &(\forall \vec x.\: (\lnot \ell \proj A \rightarrow I_1)  \land 
      (\ell \proj A \rightarrow I_2)) \rightarrow I_3 \tag{ind}\\
%
      &I_3 \rightarrow (\exists \vec x.\:
      (\lnot \ell \proj B \land I_1)  \lor
      (\ell \proj B \land I_2)) \tag{cont}
    \end{align*}
    then $I_3$ is a partial interpolant of $C_3$.
  \end{lemma}
  \else
  To concretise our setting we label a clause $C$ of the proof tree with an
  interpolation pattern $I$ from which we derive two interpolants $I\S$ and
  $I\W$.  The condition that the strong interpolant implies the weak
  interpolant can be expressed as
  \[ \lnot C\proj A \lor \lnot C\proj B \models I\S \rightarrow I\W.
  \tag{s-w}\]
  We will ensure this property when we define how the weak and strong
  interpolants are derived from an interpolant pattern.
  
  \begin{lemma}[Strong-Weak-Interpolation]\label{lem:weakstrongip}
    Given a mixed literal $\ell$ with auxiliary variable(s) $\vec x$
    and clauses $C_1\lor\ell$ and $C_2\lor\lnot\ell$ with corresponding 
    partial interpolant patterns $I_1$ resp.\ $I_2$, i.\,e., $I_1\S$ and
    $I_1\W$ (resp.\ $I_2\S$ and $I_2\W$) are partial interpolants of
    $C_1\lor \ell$ (resp.\ $C_2\lor\lnot\ell$).  Let $C_3=C_1\lor C_2$ 
    be the result of a resolution step
    on $C_1\lor\ell$ and $C_2\lor\lnot\ell$ with pivot $\ell$.
    If a partial interpolant pattern $I_3$ satisfies (s-w), the symbol
    condition, and
    \begin{align*}
      &(\forall \vec x.\: (\lnot \ell \proj A \rightarrow I_1\S)  \land 
      (\ell \proj A \rightarrow I_2\S)) \rightarrow I\S_3 \tag{ind}\\
%
      &I_3\W \rightarrow (\exists \vec x.\:
      (\lnot \ell \proj B \land I_1\W)  \lor
      (\ell \proj B \land I_2\W)) \tag{cont}
    \end{align*}
    then $I_3\S$ and $I_3\W$ are partial interpolants of $C_3$.
  \end{lemma}
  \fi

  \begin{proof}
    We need to show inductivity and contradiction for the partial interpolants.
    \subsubsection*{Inductivity.}
    For this we use inductivity of $I_1\S$ and $I_2\S$:
    \begin{align*}
      & A \land \lnot C_1 \proj A \land \lnot \ell\proj A \models I_1\S \\
      & A \land \lnot C_2 \proj A \land \ell\proj A \models I_2\S
    \end{align*}
    Since $\vec x$ does not appear in $C_1\proj A$, $C_2 \proj A$ nor $A$,
    we can conclude
    \begin{align*}
      & A \land \lnot C_1 \proj A \models \forall \vec x.\: \lnot \ell\proj A \rightarrow I_1\S \\
      & A \land \lnot C_2 \proj A \models \forall \vec x.\: \ell\proj A \rightarrow I_2\S
    \end{align*}
    Combining these and pulling the quantifier over the conjunction gives
    \begin{align*}
      & A \land \lnot C_1 \proj A \land \lnot C_2 \proj A 
       \models \forall \vec x.\: (\lnot \ell\proj A \rightarrow I_1\S) \land
                                (\ell\proj A \rightarrow I_2\S)
    \end{align*}
    Using (ind), this shows that inductivity for  $I_3\S$ holds:
    \[A \land \lnot C_1\proj A \land \lnot C_2\proj A \models I_3\S.\]
    \ifnewinterpolation\else
%
    Using (s-w) we immediately get inductivity for $I_3\W$:
    \[A \land \lnot C_1\proj A \land \lnot C_2\proj A \models I_3\W.\]
    \fi

    \subsubsection*{Contradiction.}
    First, we show the contradiction property for $I_3\W$:
    \[B \land \lnot C_1 \proj B \land \lnot C_2 \proj B \land I_3\W \models \bot.\]
    Assume the formulae on the left-hand side hold.  From (cond) we can conclude that there is some $\vec x$ such that 
    \[(\lnot \ell \proj B \land I_1\W)  \lor
      (\ell \proj B \land I_2\W)\]
    If the first disjunct is true we can derive the contradiction
    using the contradiction property of $I_1\W$:
    \begin{align*}
      & B \land \lnot C_1 \proj B \land \lnot \ell\proj B \land I_1\W \models \bot 
    \end{align*}  
    Otherwise, the second disjunct holds and we can use the contradiction
    property of $I_2\W$
    \begin{align*}
      & B \land \lnot C_2 \proj B \land \ell\proj B  \land I_2\W \models \bot
    \end{align*}  
%
    This shows the contradiction property for $I_3\W$.
    \ifnewinterpolation\else
    Using (s-w) we immediately get the contradiction property for $I_3\S$: 
    \[B \land \lnot C_1 \proj B \land \lnot C_2 \proj B \land I_3\S \models
    \bot.\]

    \vspace{-19pt}\strut
    \fi\qed
  \end{proof}
\end{techreport}

It is important to state here that the given purification of a
literal into two new literals is not a modification of the proof tree
or any of its nodes. The proof tree would no longer be well-formed if
we replaced a mixed literal by the disjunction or conjunction of the
purified parts.  The purification is only used to define partial
interpolants of clauses.  In fact, it is only used in the
correctness proof of our method and is not even done explicitly in the
implementation.
